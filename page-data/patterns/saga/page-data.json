{"componentChunkName":"component---src-pages-patterns-saga-index-mdx","path":"/patterns/saga/","result":{"pageContext":{"frontmatter":{"title":"Patterns in Event-Driven Architectures","description":"Saga pattern"},"relativePagePath":"/patterns/saga/index.mdx","titleType":"append","MdxNode":{"id":"5517534f-c8c6-56e8-b19a-7d77132b11f5","children":[],"parent":"4ee80549-d9d4-5f54-bfa8-6fe03411aa60","internal":{"content":"---\ntitle: Patterns in Event-Driven Architectures\ndescription: Saga pattern\n---\n\n# Saga\n\n## Problems and Constraints\n\nWith the adoption of one data source per microservice, there is an interesting challenge on how to support long running transaction cross microservices. With event backbone two phase commit is not an option.\n\n## Solution and Pattern\n\nIntroduced in 1987 [by Hector Garcaa-Molrna Kenneth Salem paper](https://www.cs.cornell.edu/andru/cs711/2002fa/reading/sagas.pdf) the Saga pattern helps to support a long running transaction that can be broken up to a collection of sub transactions that can be interleaved any way with other transactions.\n\nWith microservice each transaction updates data within a single service, each subsequent steps may be triggered by previous completion. The following figure, based on [our solution implementation](https://ibm-cloud-architecture.github.io/refarch-kc), illustrates those concepts for an order transaction:\n\n![1](./images/saga-ctx.png)\n\nWhen the order is created, the business process says, we need to allocate a \"voyage\" (a Vessel container carrier), assign refrigerator containers and update the list of containers to load on the ship. \nThose actions / commands are chained. The final state (in this schema, not in the reality, as the process has more steps) \nis the Order assigned state in the order microservice.\n\nWith a unique application implementation, the integrity between order, voyage and container tables will be done via transactions. \nWith distributed system we could not easily apply two phase commit transaction so the Saga pattern will help.\n\nSAGA pattern supports two types of implementation: Choreography and Orchestration.\n\n## Services choreography\n\nWith Choreography each service produces and listens to other service’s events and decides if an action should be taken or not.\n\n![2](./images/saga-choreo.png)\n\nThe first service executes a transaction to its own data store and then publishes an event ( OrderCreated event (1)) as fact about its business entity update. \nIt maintains the business entity status, (order.status) to the `Pending` state until the saga is completed. This event is listened by one or more services which execute local\n transactions and publish new events (VoyageAllocated (3), ReeferAssigned (4), PaymentProcessed (5)).\nThe distributed transaction ends when the last service executes its local transaction or when a service does not publish any events or the event published is not \npolled by any of the saga’s participants. For example, the Order microservice gets all the events from the other services and changed the Order state to be `Accepted`.\n\nIn case of failure, the source microservice is keeping state and timer to monitor for the expected completion events.\n\n![3](./images/saga-choreo-fail.png)\n\nWhen a message from any service is missing, the source service, needs to trigger a compensation process:\n\n![4](./images/saga-compensation.png)\n\nRolling back a distributed transaction does not come for free. Normally you have to implement another operation/transaction to compensate for what has been done before. This will be a new event sent by the service responsible of the transaction integrity. In the order example, in the rare case where one of the service is not able to provide a positive response, no voyage found, or no Reefer container found, then the order needs to change to 'Uncompleted' status, and an event to the orders topic will claim the orderID is now uncompleted (OrderUncompleted event Step 1 above) . Any service that has something allocated for this orderId will 'unroll' their changes in their own data source  (Steps 2,3,4 below).\n\nAlso it is important to note, that if one of the service is taking time to answer this may not be a problem as the order is in pending state. If the business requirement stipulates to address an order within a small time period then the compensation process may start. Uncompleted orders can be reviewed by a business user for manual handling. Email can be automatically sent to the customer about issue related to his order. There are a lot of different ways to handle order issue at the business level.\n\n[See the eda-saga-choreography repository](https://ibm-cloud-architecture.github.io/eda-saga-choreography/) for the last code and example on how to run a simple demonstration with three services.\n\n## Services orchestration\n\nWith orchestration, one service is responsible to drive each participant on what to do and when. As we do not\nwant to loose any message as part of this orchestration the technology of choice to support strong consistency\nand exactly once delivery, is to use IBM MQ, as illustrated by the following figure:\n\n![Saga with MQ](./images/saga-orchestration-mq.png)\n\nAn example of Saga implementation using MQ is described in [this repository](https://github.com/ibm-cloud-architecture/eda-kc-gitops) and the orchestration implemenation with MQ is in the [eda-kc-order-cmd-mq repo](https://github.com/ibm-cloud-architecture/eda-kc-order-cmd-mq).\n\nAn alternate approach is to use [Kafka with producer](https://ibm-cloud-architecture.github.io/eda-saga-orchestration/) using full acknowledge, idempotence, and a batch size of 1, and different topics\nmostly configured as queue: one consumer in each consumer group, manual commit, poll one message at a time.\n\n![Saga with topics](./images/saga-orchestration-kafka.png)\n\nIt uses the different topics to control the saga by issuing event commands to the different service. It uses the event backbone as a queue processing to \nsupport the asynchronous invocations. In this case the event should be exactly once delivered and idempotent. Each participant produces response in their \ncontext and to the order topic. The orchestration layer needs to keep a state machine and acts once all the expected responses are received.\n\nIf anything fails, the orchestrator is also responsible for coordinating the compensation process by sending rollback events with orderID and their respective impacted entity key (voyageID, reeferID, transactionID). Each  participant will undo its previous operations.\nOrchestrator is a State Machine where each transformation corresponds to a command or message.\n\nSee also [this article](https://microservices.io/patterns/data/saga.html) from Chris Richardson on the Saga pattern.\n\nWe have implemented the choreography saga pattern in the order management, voyage and refeer management microservices within the [EDA reference implementation solution](https://ibm-cloud-architecture.github.io/refarch-kc/implementation/saga-patterns/) with a detailed explanation of the integration tests to validate the [happy path](https://ibm-cloud-architecture.github.io/refarch-kc/integration-tests/happy-path/), and the [exception path](https://ibm-cloud-architecture.github.io/refarch-kc/integration-tests/saga-pattern/) with compensation.\n\n## Repositories to demonstrate the Saga patterns\n\n* [eda-saga-choreography repository](https://ibm-cloud-architecture.github.io/eda-saga-choreography/)\n\n    * [Order service](https://github.com/ibm-cloud-architecture/refarch-kc-order-cmd-ms.git)\n    * [Reefer service](https://github.com/ibm-cloud-architecture/refarch-kc-reefer-ms.git)\n    * [Voyage service](https://github.com/ibm-cloud-architecture/refarch-kc-voyage-ms.git)\n\n* [eda-saga-orchestration repository](https://ibm-cloud-architecture.github.io/eda-saga-orchestration/) includes subfolders with the 3 services.\n","type":"Mdx","contentDigest":"4a3a3f453068ce800255e59da945c101","owner":"gatsby-plugin-mdx","counter":925},"frontmatter":{"title":"Patterns in Event-Driven Architectures","description":"Saga pattern"},"exports":{},"rawBody":"---\ntitle: Patterns in Event-Driven Architectures\ndescription: Saga pattern\n---\n\n# Saga\n\n## Problems and Constraints\n\nWith the adoption of one data source per microservice, there is an interesting challenge on how to support long running transaction cross microservices. With event backbone two phase commit is not an option.\n\n## Solution and Pattern\n\nIntroduced in 1987 [by Hector Garcaa-Molrna Kenneth Salem paper](https://www.cs.cornell.edu/andru/cs711/2002fa/reading/sagas.pdf) the Saga pattern helps to support a long running transaction that can be broken up to a collection of sub transactions that can be interleaved any way with other transactions.\n\nWith microservice each transaction updates data within a single service, each subsequent steps may be triggered by previous completion. The following figure, based on [our solution implementation](https://ibm-cloud-architecture.github.io/refarch-kc), illustrates those concepts for an order transaction:\n\n![1](./images/saga-ctx.png)\n\nWhen the order is created, the business process says, we need to allocate a \"voyage\" (a Vessel container carrier), assign refrigerator containers and update the list of containers to load on the ship. \nThose actions / commands are chained. The final state (in this schema, not in the reality, as the process has more steps) \nis the Order assigned state in the order microservice.\n\nWith a unique application implementation, the integrity between order, voyage and container tables will be done via transactions. \nWith distributed system we could not easily apply two phase commit transaction so the Saga pattern will help.\n\nSAGA pattern supports two types of implementation: Choreography and Orchestration.\n\n## Services choreography\n\nWith Choreography each service produces and listens to other service’s events and decides if an action should be taken or not.\n\n![2](./images/saga-choreo.png)\n\nThe first service executes a transaction to its own data store and then publishes an event ( OrderCreated event (1)) as fact about its business entity update. \nIt maintains the business entity status, (order.status) to the `Pending` state until the saga is completed. This event is listened by one or more services which execute local\n transactions and publish new events (VoyageAllocated (3), ReeferAssigned (4), PaymentProcessed (5)).\nThe distributed transaction ends when the last service executes its local transaction or when a service does not publish any events or the event published is not \npolled by any of the saga’s participants. For example, the Order microservice gets all the events from the other services and changed the Order state to be `Accepted`.\n\nIn case of failure, the source microservice is keeping state and timer to monitor for the expected completion events.\n\n![3](./images/saga-choreo-fail.png)\n\nWhen a message from any service is missing, the source service, needs to trigger a compensation process:\n\n![4](./images/saga-compensation.png)\n\nRolling back a distributed transaction does not come for free. Normally you have to implement another operation/transaction to compensate for what has been done before. This will be a new event sent by the service responsible of the transaction integrity. In the order example, in the rare case where one of the service is not able to provide a positive response, no voyage found, or no Reefer container found, then the order needs to change to 'Uncompleted' status, and an event to the orders topic will claim the orderID is now uncompleted (OrderUncompleted event Step 1 above) . Any service that has something allocated for this orderId will 'unroll' their changes in their own data source  (Steps 2,3,4 below).\n\nAlso it is important to note, that if one of the service is taking time to answer this may not be a problem as the order is in pending state. If the business requirement stipulates to address an order within a small time period then the compensation process may start. Uncompleted orders can be reviewed by a business user for manual handling. Email can be automatically sent to the customer about issue related to his order. There are a lot of different ways to handle order issue at the business level.\n\n[See the eda-saga-choreography repository](https://ibm-cloud-architecture.github.io/eda-saga-choreography/) for the last code and example on how to run a simple demonstration with three services.\n\n## Services orchestration\n\nWith orchestration, one service is responsible to drive each participant on what to do and when. As we do not\nwant to loose any message as part of this orchestration the technology of choice to support strong consistency\nand exactly once delivery, is to use IBM MQ, as illustrated by the following figure:\n\n![Saga with MQ](./images/saga-orchestration-mq.png)\n\nAn example of Saga implementation using MQ is described in [this repository](https://github.com/ibm-cloud-architecture/eda-kc-gitops) and the orchestration implemenation with MQ is in the [eda-kc-order-cmd-mq repo](https://github.com/ibm-cloud-architecture/eda-kc-order-cmd-mq).\n\nAn alternate approach is to use [Kafka with producer](https://ibm-cloud-architecture.github.io/eda-saga-orchestration/) using full acknowledge, idempotence, and a batch size of 1, and different topics\nmostly configured as queue: one consumer in each consumer group, manual commit, poll one message at a time.\n\n![Saga with topics](./images/saga-orchestration-kafka.png)\n\nIt uses the different topics to control the saga by issuing event commands to the different service. It uses the event backbone as a queue processing to \nsupport the asynchronous invocations. In this case the event should be exactly once delivered and idempotent. Each participant produces response in their \ncontext and to the order topic. The orchestration layer needs to keep a state machine and acts once all the expected responses are received.\n\nIf anything fails, the orchestrator is also responsible for coordinating the compensation process by sending rollback events with orderID and their respective impacted entity key (voyageID, reeferID, transactionID). Each  participant will undo its previous operations.\nOrchestrator is a State Machine where each transformation corresponds to a command or message.\n\nSee also [this article](https://microservices.io/patterns/data/saga.html) from Chris Richardson on the Saga pattern.\n\nWe have implemented the choreography saga pattern in the order management, voyage and refeer management microservices within the [EDA reference implementation solution](https://ibm-cloud-architecture.github.io/refarch-kc/implementation/saga-patterns/) with a detailed explanation of the integration tests to validate the [happy path](https://ibm-cloud-architecture.github.io/refarch-kc/integration-tests/happy-path/), and the [exception path](https://ibm-cloud-architecture.github.io/refarch-kc/integration-tests/saga-pattern/) with compensation.\n\n## Repositories to demonstrate the Saga patterns\n\n* [eda-saga-choreography repository](https://ibm-cloud-architecture.github.io/eda-saga-choreography/)\n\n    * [Order service](https://github.com/ibm-cloud-architecture/refarch-kc-order-cmd-ms.git)\n    * [Reefer service](https://github.com/ibm-cloud-architecture/refarch-kc-reefer-ms.git)\n    * [Voyage service](https://github.com/ibm-cloud-architecture/refarch-kc-voyage-ms.git)\n\n* [eda-saga-orchestration repository](https://ibm-cloud-architecture.github.io/eda-saga-orchestration/) includes subfolders with the 3 services.\n","fileAbsolutePath":"/home/runner/work/refarch-eda/refarch-eda/docs/src/pages/patterns/saga/index.mdx"}}},"staticQueryHashes":["1364590287","137577622","137577622","2102389209","2102389209","2456312558","2746626797","2746626797","3018647132","3018647132","3037994772","3037994772","768070550"]}