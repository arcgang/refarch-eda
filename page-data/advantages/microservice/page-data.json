{"componentChunkName":"component---src-pages-advantages-microservice-index-mdx","path":"/advantages/microservice/","result":{"pageContext":{"frontmatter":{"title":"Advantages of Event-Driven Reference Architectures - Microservice","description":"en architectures,Advantages of event-driv related to microservice communication."},"relativePagePath":"/advantages/microservice/index.mdx","titleType":"append","MdxNode":{"id":"02032540-1f25-57ae-a77e-eedb797b7286","children":[],"parent":"e21b534a-926b-5a36-af34-f5b24cbbba16","internal":{"content":"---\ntitle: Advantages of Event-Driven Reference Architectures - Microservice\ndescription: en architectures,Advantages of event-driv related to microservice communication.\n---\n\n<InlineNotification kind=\"warning\">\n<strong>Updated 10/07/2021</strong>\n</InlineNotification>\n\nAs we have seen in the introduction, modern business application needs to responds to events in real time, \nas the event happen, so it can deliver better user experiences and apply business rule on those events. \nThe key is to be able to act quickly on those facts. Acting may involve computing analytics or machine \ntrained models. \n\nOn top of that a modern cloud native application needs to be reactive, responsive by adopting the [reactive manifesto](/advantages/reactive). \nWe can also claim they are becoming intelligence by integrating rule engine and predictive scoring / AI capabilities. \n\nWhen adopting microservice implementation approach, the bounded context is defined with events and aggregates or main business entity. \nSo each microservice is responsible to manage the operations of creating, updating and reading the data from a \nmain business entity. This clear separation leads to exchange data between services, they may used to be\nintegrated in the same monolytic application before.\n\nA web application, single page app (SPA), accesses the different microservices using RESTful API, \nto get the different data views it needs, or to post new data elements to one of the service.\nThe following diagram illustrates a simple view of the microservice challenges:\n\n ![1](images/microserv-1.png)\n\nWhen the user interface exposes entry form to get data for one of the business entity, \nit calls a REST end point with a HTTP POST operation, then data are saved to data store: \ndocument oriented database or SQL based RDBMS.\n\nWhen a microservice (1) needs to access data from another service, then it calls \nanother end point via an HTTP GET. A coupling is still existing, at the data schema definition level:\na change to the data model, from the source microservice, impacts the service contract and so all the callers. \nThis may be acceptable when there is few microservices, but could become a real pain when the number increase.\n\nWhen the microservice dependencies grows in size and complexity, \nas illustrated by the following figure from [Jack Kleeman's Monzo study](https://monzo.com/blog/we-built-network-isolation-for-1-500-services), \nwe can see the coupling impact, which lead to impacting time to deliver new function and \ncost to maintain such complexity.\n\n ![2](images/microserv-2.png)\n\nFinally, imagine we need to join data coming from two different services to address an urgent business request? \nWho will implement the join, service A or B? May be the simplest is to add a service C and \nimplement the join: it will call two API end points, and try to reconcile data using primary keys \non both business entities.\n\n ![3](images/microserv-3.png)\n\nWith event-driven microservices, the communication point becomes the Pub/Sub layer of \nthe event backbone. By adopting an event-based approach for intercommunication between \nmicroservices, the microservices applications are naturally responsive (event-driven). \nThis approach enhances the loose coupling nature of microservices because it decouples \nproducers and consumers. The figure below illustrates, that microservices A and B produces\n facts about their business entities, and their life cycle to topic in the pub/sub event backbone:\n\n ![4](images/microserv-4.png)\n\nThe microservice C consumes those facts to build it own projection or view for supporting the join query.\n\nWhen adopting technology like Kafka as messaging backbone, the data sharing is \ndone via an event log, which can be kept for a very long time period, and is replayable \nto improve resilience. These event style characteristics are increasingly important \nconsiderations when you develop microservices style applications. In practical \nterms microservices applications are a combination of synchronous API-driven, \nand asynchronous event-driven communication styles. \n\nThere is something important to add, is that coupling by the data, still existing but in\na less impactful manner. Messaging structures are defined with JSON schema or Avro schema and\nmanaged inside a Schema registry, so Kafka-based applications can get their data contract.  \n\nThe following figure presents a potential structure for event-driven microservice: \nAPIs are defined using microprofile OpenAPI annotations in one or more JAXRS resource \nclasses. Those APIs can then be managed within an API management product as IBM API \nConnect.\n\n![](./images/evt-driv-ms.png)\n\nThe rest of the application structure reflects the DDD approach of onion architecture. \nThe business logic is in its own layer with DDD aggregate, ubiquitous language, services,\nbusiness rules, etcâ€¦\nThe repository layer supports persisting those aggregates to an external document-oriented \nor SQL-based database.\nAs most of the new microservices are message-driven, we are adding a messaging layer \nthat may use queues or topics. Use queue for request/response exactly once delivery \nand topic for sharing facts in append log.\nIn Java, the Microprofile Reactive Messaging is used to define the different publishing \nchannels, being queue, topic, or both.\nFrom the JSON or Avro schema defining the messages or events structure, \ndevelopers can build an AsyncAPI specification which may also be managed by an API product.","type":"Mdx","contentDigest":"85d4833ca4b76fe3069c4afadd58da97","owner":"gatsby-plugin-mdx","counter":892},"frontmatter":{"title":"Advantages of Event-Driven Reference Architectures - Microservice","description":"en architectures,Advantages of event-driv related to microservice communication."},"exports":{},"rawBody":"---\ntitle: Advantages of Event-Driven Reference Architectures - Microservice\ndescription: en architectures,Advantages of event-driv related to microservice communication.\n---\n\n<InlineNotification kind=\"warning\">\n<strong>Updated 10/07/2021</strong>\n</InlineNotification>\n\nAs we have seen in the introduction, modern business application needs to responds to events in real time, \nas the event happen, so it can deliver better user experiences and apply business rule on those events. \nThe key is to be able to act quickly on those facts. Acting may involve computing analytics or machine \ntrained models. \n\nOn top of that a modern cloud native application needs to be reactive, responsive by adopting the [reactive manifesto](/advantages/reactive). \nWe can also claim they are becoming intelligence by integrating rule engine and predictive scoring / AI capabilities. \n\nWhen adopting microservice implementation approach, the bounded context is defined with events and aggregates or main business entity. \nSo each microservice is responsible to manage the operations of creating, updating and reading the data from a \nmain business entity. This clear separation leads to exchange data between services, they may used to be\nintegrated in the same monolytic application before.\n\nA web application, single page app (SPA), accesses the different microservices using RESTful API, \nto get the different data views it needs, or to post new data elements to one of the service.\nThe following diagram illustrates a simple view of the microservice challenges:\n\n ![1](images/microserv-1.png)\n\nWhen the user interface exposes entry form to get data for one of the business entity, \nit calls a REST end point with a HTTP POST operation, then data are saved to data store: \ndocument oriented database or SQL based RDBMS.\n\nWhen a microservice (1) needs to access data from another service, then it calls \nanother end point via an HTTP GET. A coupling is still existing, at the data schema definition level:\na change to the data model, from the source microservice, impacts the service contract and so all the callers. \nThis may be acceptable when there is few microservices, but could become a real pain when the number increase.\n\nWhen the microservice dependencies grows in size and complexity, \nas illustrated by the following figure from [Jack Kleeman's Monzo study](https://monzo.com/blog/we-built-network-isolation-for-1-500-services), \nwe can see the coupling impact, which lead to impacting time to deliver new function and \ncost to maintain such complexity.\n\n ![2](images/microserv-2.png)\n\nFinally, imagine we need to join data coming from two different services to address an urgent business request? \nWho will implement the join, service A or B? May be the simplest is to add a service C and \nimplement the join: it will call two API end points, and try to reconcile data using primary keys \non both business entities.\n\n ![3](images/microserv-3.png)\n\nWith event-driven microservices, the communication point becomes the Pub/Sub layer of \nthe event backbone. By adopting an event-based approach for intercommunication between \nmicroservices, the microservices applications are naturally responsive (event-driven). \nThis approach enhances the loose coupling nature of microservices because it decouples \nproducers and consumers. The figure below illustrates, that microservices A and B produces\n facts about their business entities, and their life cycle to topic in the pub/sub event backbone:\n\n ![4](images/microserv-4.png)\n\nThe microservice C consumes those facts to build it own projection or view for supporting the join query.\n\nWhen adopting technology like Kafka as messaging backbone, the data sharing is \ndone via an event log, which can be kept for a very long time period, and is replayable \nto improve resilience. These event style characteristics are increasingly important \nconsiderations when you develop microservices style applications. In practical \nterms microservices applications are a combination of synchronous API-driven, \nand asynchronous event-driven communication styles. \n\nThere is something important to add, is that coupling by the data, still existing but in\na less impactful manner. Messaging structures are defined with JSON schema or Avro schema and\nmanaged inside a Schema registry, so Kafka-based applications can get their data contract.  \n\nThe following figure presents a potential structure for event-driven microservice: \nAPIs are defined using microprofile OpenAPI annotations in one or more JAXRS resource \nclasses. Those APIs can then be managed within an API management product as IBM API \nConnect.\n\n![](./images/evt-driv-ms.png)\n\nThe rest of the application structure reflects the DDD approach of onion architecture. \nThe business logic is in its own layer with DDD aggregate, ubiquitous language, services,\nbusiness rules, etcâ€¦\nThe repository layer supports persisting those aggregates to an external document-oriented \nor SQL-based database.\nAs most of the new microservices are message-driven, we are adding a messaging layer \nthat may use queues or topics. Use queue for request/response exactly once delivery \nand topic for sharing facts in append log.\nIn Java, the Microprofile Reactive Messaging is used to define the different publishing \nchannels, being queue, topic, or both.\nFrom the JSON or Avro schema defining the messages or events structure, \ndevelopers can build an AsyncAPI specification which may also be managed by an API product.","fileAbsolutePath":"/home/runner/work/refarch-eda/refarch-eda/docs/src/pages/advantages/microservice/index.mdx"}}},"staticQueryHashes":["1364590287","137577622","137577622","2102389209","2102389209","2456312558","2746626797","2746626797","3018647132","3018647132","3037994772","3037994772","768070550"]}